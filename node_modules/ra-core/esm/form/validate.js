var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import lodashMemoize from 'lodash/memoize';
/* eslint-disable no-underscore-dangle */
/* @link http://stackoverflow.com/questions/46155/validate-email-address-in-javascript */
var EMAIL_REGEX = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/; // eslint-disable-line no-useless-escape
var isEmpty = function (value) {
    return typeof value === 'undefined' || value === null || value === '';
};
var getMessage = function (message, messageArgs, value, values, props) {
    return typeof message === 'function'
        ? message(__assign({ args: messageArgs, value: value,
            values: values }, props))
        : props.translate(message, __assign({ _: message }, messageArgs));
};
// If we define validation functions directly in JSX, it will
// result in a new function at every render, and then trigger infinite re-render.
// Hence, we memoize every built-in validator to prevent a "Maximum call stack" error.
var memoize = function (fn) { return lodashMemoize(fn, function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return JSON.stringify(args);
}); };
export var required = memoize(function (message) {
    if (message === void 0) { message = 'ra.validation.required'; }
    return Object.assign(function (value, values, props) {
        return isEmpty(value)
            ? getMessage(message, undefined, value, values, props)
            : undefined;
    }, { isRequired: true });
});
export var minLength = memoize(function (min, message) {
    if (message === void 0) { message = 'ra.validation.minLength'; }
    return function (value, values, props) {
        return !isEmpty(value) && value.length < min
            ? getMessage(message, { min: min }, value, values, props)
            : undefined;
    };
});
export var maxLength = memoize(function (max, message) {
    if (message === void 0) { message = 'ra.validation.maxLength'; }
    return function (value, values, props) {
        return !isEmpty(value) && value.length > max
            ? getMessage(message, { max: max }, value, values, props)
            : undefined;
    };
});
export var minValue = memoize(function (min, message) {
    if (message === void 0) { message = 'ra.validation.minValue'; }
    return function (value, values, props) {
        return !isEmpty(value) && value < min
            ? getMessage(message, { min: min }, value, values, props)
            : undefined;
    };
});
export var maxValue = memoize(function (max, message) {
    if (message === void 0) { message = 'ra.validation.maxValue'; }
    return function (value, values, props) {
        return !isEmpty(value) && value > max
            ? getMessage(message, { max: max }, value, values, props)
            : undefined;
    };
});
// tslint:disable-next-line:variable-name
export var number = memoize(function (message) {
    if (message === void 0) { message = 'ra.validation.number'; }
    return function (value, values, props) {
        return !isEmpty(value) && isNaN(Number(value))
            ? getMessage(message, undefined, value, values, props)
            : undefined;
    };
});
export var regex = lodashMemoize(function (pattern, message) {
    if (message === void 0) { message = 'ra.validation.regex'; }
    return function (value, values, props) {
        return !isEmpty(value) && typeof value === 'string' && !pattern.test(value)
            ? getMessage(message, { pattern: pattern }, value, values, props)
            : undefined;
    };
}, function (pattern, message) {
    return pattern.toString() + message;
});
export var email = memoize(function (message) {
    if (message === void 0) { message = 'ra.validation.email'; }
    return regex(EMAIL_REGEX, message);
});
var oneOfTypeMessage = function (_a, value, values, _b) {
    var list = _a.list;
    var translate = _b.translate;
    translate('ra.validation.oneOf', {
        options: list.join(', '),
    });
};
export var choices = memoize(function (list, message) {
    if (message === void 0) { message = oneOfTypeMessage; }
    return function (value, values, props) {
        return !isEmpty(value) && list.indexOf(value) === -1
            ? getMessage(message, { list: list }, value, values, props)
            : undefined;
    };
});
